import { Injectable, OnModuleInit } from '@nestjs/common';
import { CommandRunner } from 'nest-commander';

/**
 * Base Command
 *
 * Abstract base class providing common functionality for all CLI commands.
 * Provides command execution utilities like call() and callSilent() similar
 * to Symfony and Laravel console commands.
 *
 * @description Provides command execution utilities for calling other commands
 * @author Generated by @nesvel/nestjs-console
 *
 * @example
 * ```typescript
 * @Command({
 *   name: 'my:command',
 *   description: 'My custom command',
 * })
 * export class MyCommand extends BaseCommand {
 *   async run(): Promise<void> {
 *     await this.call('make:model', ['User']);
 *   }
 * }
 * ```
 */
@Injectable()
export abstract class BaseCommand extends CommandRunner {
  /**
   * Map of registered commands by name
   */
  private static commandMap = new Map<string, CommandRunner>();

  constructor() {
    super();
    // Auto-register this command by reading its decorator metadata
    this.registerSelf();
  }

  /**
   * Auto-register this command instance using decorator metadata
   */
  private registerSelf() {
    // nest-commander uses 'CommandBuilder:Command:Meta' as the metadata key
    const metadata = Reflect.getMetadata('CommandBuilder:Command:Meta', this.constructor);

    if (metadata?.name) {
      BaseCommand.commandMap.set(metadata.name, this);
    }
  }

  /**
   * Register a command instance manually (for testing or special cases)
   */
  static registerCommand(name: string, instance: CommandRunner) {
    BaseCommand.commandMap.set(name, instance);
  }

  /**
   * Abstract method that must be implemented by all concrete command classes
   *
   * @param inputs - Command arguments
   * @param options - Command options
   */
  abstract run(inputs?: string[], options?: Record<string, any>): Promise<void>;

  /**
   * Call another command by name
   *
   * Executes another command with the given arguments and options,
   * showing output to the user (similar to Symfony/Laravel's call method).
   *
   * @param commandName - The name of the command to execute
   * @param args - Array of arguments and options to pass to the command
   * @returns Promise that resolves when the command completes
   *
   * @example
   * ```typescript
   * await this.call('make:model', ['User']);
   * await this.call('make:controller', ['UserController', '--path', 'src/api']);
   * ```
   */
  protected async call(commandName: string, args: string[] = []): Promise<void> {
    await this.executeCommand(commandName, args, false);
  }

  /**
   * Call another command silently
   *
   * Executes another command with the given arguments and options,
   * suppressing all output (similar to Symfony/Laravel's callSilent method).
   *
   * @param commandName - The name of the command to execute
   * @param args - Array of arguments and options to pass to the command
   * @returns Promise that resolves when the command completes
   *
   * @example
   * ```typescript
   * await this.callSilent('make:model', ['User']);
   * await this.callSilent('make:controller', ['UserController']);
   * ```
   */
  protected async callSilent(commandName: string, args: string[] = []): Promise<void> {
    await this.executeCommand(commandName, args, true);
  }

  /**
   * Execute a command with or without output suppression
   *
   * @private
   * @param commandName - The name of the command to execute
   * @param args - Array of arguments and options to pass to the command
   * @param silent - Whether to suppress output
   */
  private async executeCommand(
    commandName: string,
    args: string[] = [],
    silent: boolean = false,
  ): Promise<void> {
    // Get command from the registered command map
    const commandInstance = BaseCommand.commandMap.get(commandName);

    if (!commandInstance) {
      throw new Error(`Command not found: ${commandName}. Make sure the command is registered.`);
    }

    // Parse arguments and options
    const { inputs, options } = this.parseArgs(args);

    // Save original customPath and set new one if provided
    // This mimics what the @Option decorator would do
    let customPathWasSet = false;
    const originalCustomPath = (commandInstance as any).customPath;

    if (options.path) {
      (commandInstance as any).customPath = options.path;
      customPathWasSet = true;
    }

    // Suppress console output if silent
    const originalLog = console.log;
    const originalError = console.error;
    const originalWarn = console.warn;
    const originalInfo = console.info;

    if (silent) {
      console.log = () => {};
      console.error = () => {};
      console.warn = () => {};
      console.info = () => {};
    }

    try {
      await commandInstance.run(inputs, options);
    } finally {
      // Restore original customPath only if we changed it
      if (customPathWasSet && 'customPath' in commandInstance) {
        (commandInstance as any).customPath = originalCustomPath;
      }
      // Restore console output
      if (silent) {
        console.log = originalLog;
        console.error = originalError;
        console.warn = originalWarn;
        console.info = originalInfo;
      }
    }
  }

  /**
   * Parse arguments array into inputs and options
   *
   * @private
   * @param args - Array of arguments and options
   * @returns Object with inputs and options
   */
  private parseArgs(args: string[]): {
    inputs: string[];
    options: Record<string, any>;
  } {
    const inputs: string[] = [];
    const options: Record<string, any> = {};

    for (let i = 0; i < args.length; i++) {
      const arg = args[i];

      if (!arg) continue;

      if (arg.startsWith('--')) {
        // Long option
        const key = arg.slice(2);
        const nextArg = args[i + 1];

        if (nextArg && !nextArg.startsWith('-')) {
          options[key] = nextArg;
          i++;
        } else {
          options[key] = true;
        }
      } else if (arg.startsWith('-')) {
        // Short option
        const key = arg.slice(1);
        const nextArg = args[i + 1];

        if (nextArg && !nextArg.startsWith('-')) {
          options[key] = nextArg;
          i++;
        } else {
          options[key] = true;
        }
      } else {
        // Regular input
        inputs.push(arg);
      }
    }

    return { inputs, options };
  }
}
