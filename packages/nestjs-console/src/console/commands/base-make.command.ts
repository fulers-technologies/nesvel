import * as fs from 'fs';
import * as ejs from 'ejs';
import * as path from 'path';
import { Option } from 'nest-commander';
import { Injectable } from '@nestjs/common';

import { spinner } from '@/prompts';
import { BaseCommand } from './base.command';
import { success, error as errorLog } from '@/messages';
import type { MakeCommandOptions } from '@/interfaces/make-command-options.interface';

/**
 * Base Make Command
 *
 * Abstract base class providing common functionality for Laravel-style make commands.
 * All make commands (model, repository, service, etc.) extend this class to inherit
 * file generation capabilities using EJS templates.
 *
 * Uses nest-commander for CLI command handling with support for arguments and options.
 *
 * @description Provides template rendering, file generation, and naming convention utilities
 * @author Generated by @nesvel/nestjs-console
 *
 * @example
 * ```typescript
 * @Command({
 *   name: 'make:model',
 *   arguments: '<name>',
 *   description: 'Create a new model',
 * })
 * export class MakeModelCommand extends BaseMakeCommand {
 *   async run(inputs: string[]): Promise<void> {
 *     const [name] = inputs;
 *     await this.generateFromStub(name, {
 *       stubName: 'model',
 *       outputDir: 'src/entities',
 *     });
 *   }
 * }
 * ```
 */
@Injectable()
export abstract class BaseMakeCommand extends BaseCommand {
  /**
   * Path to the stubs directory containing EJS templates
   *
   * @protected
   * @readonly
   */
  protected stubsPath: string;

  /**
   * Whether tsconfig.json exists with path aliases
   *
   * @protected
   */
  protected hasTsconfigWithAliases: boolean = false;

  constructor() {
    super();

    // Get the directory of the current file (works in both CJS and ESM)
    // In the built package, this will resolve to the dist folder
    this.stubsPath = this.getStubsPath();

    // Check if tsconfig.json exists with path aliases
    this.hasTsconfigWithAliases = this.checkTsconfigAliases();
  }

  /**
   * Get the stubs path - can be overridden by subclasses
   */
  protected getStubsPath(): string {
    // This will be resolved at runtime from the built dist folder
    // Subclasses can override this method to provide their own stubs path

    // Handle both CommonJS and ESM
    // In CommonJS, __dirname is available
    // In ESM, we need to use a different approach
    try {
      // Try CommonJS first
      if (typeof __dirname !== 'undefined') {
        return path.join(__dirname, 'stubs');
      }
    } catch (e: Error | any) {
      // __dirname reference error in ESM
    }

    // Fallback for ESM: try to find the package location
    // Look for the package in node_modules
    const possiblePaths = [
      path.join(process.cwd(), 'node_modules', '@nesvel', 'nestjs-console', 'dist', 'stubs'),
      path.join(process.cwd(), '..', '..', 'packages', 'nestjs-console', 'dist', 'stubs'),
    ];

    for (const stubPath of possiblePaths) {
      if (fs.existsSync(stubPath)) {
        return stubPath;
      }
    }

    // Last resort: assume we're in the dist folder
    return path.join(process.cwd(), 'stubs');
  }

  /**
   * Find project root by looking for package.json
   * Can be overridden by subclasses for custom root detection
   */
  protected findProjectRoot(): string {
    let currentDir = process.cwd();

    while (currentDir !== '/') {
      if (fs.existsSync(path.join(currentDir, 'package.json'))) {
        return currentDir;
      }
      currentDir = path.dirname(currentDir);
    }

    // Fallback to cwd if package.json not found
    return process.cwd();
  }

  /**
   * Check if tsconfig.json exists and has path aliases configured
   *
   * @returns True if tsconfig exists with path aliases
   */
  protected checkTsconfigAliases(): boolean {
    try {
      const projectRoot = this.findProjectRoot();
      const tsconfigPath = path.join(projectRoot, 'tsconfig.json');

      if (!fs.existsSync(tsconfigPath)) {
        return false;
      }

      const tsconfigContent = fs.readFileSync(tsconfigPath, 'utf-8');
      const tsconfig = JSON.parse(tsconfigContent);

      // Check if compilerOptions.paths exists and has at least one alias
      return (
        tsconfig.compilerOptions?.paths && Object.keys(tsconfig.compilerOptions.paths).length > 0
      );
    } catch (error: Error | any) {
      return false;
    }
  }

  /**
   * Warn about missing tsconfig if path aliases would be used
   */
  protected warnAboutMissingTsconfig(): void {
    if (!this.hasTsconfigWithAliases) {
      console.warn(
        '\n⚠️  Warning: tsconfig.json with path aliases not found.\n' +
          '   Generated files may have commented import statements.\n' +
          '   Run `make:tsconfig` to create a tsconfig with path aliases.\n',
      );
    }
  }

  /**
   * Custom output path override
   *
   * @protected
   */
  protected customPath?: string;

  /**
   * Option to override the output directory path
   *
   * @param val - Custom output directory path
   */
  @Option({
    flags: '--path <path>',
    description: 'Override the output directory path',
  })
  parsePath(val: string): void {
    this.customPath = val;
  }

  /**
   * Generate a file from a stub template
   *
   * Reads an EJS stub template, renders it with the provided variables,
   * and writes the result to the output directory. Handles name normalization,
   * directory creation, and duplicate file checking.
   *
   * @param name - The base name for the generated file (e.g., 'User', 'Product')
   * @param options - Configuration options for file generation
   * @param additionalVars - Additional variables to pass to the EJS template
   * @returns Promise that resolves when file generation is complete
   *
   * @example
   * ```typescript
   * await this.generateFromStub('User', {
   *   stubName: 'model',
   *   outputDir: 'src/entities',
   * });
   * ```
   */
  protected async generateFromStub(
    name: string,
    options: MakeCommandOptions,
    additionalVars: Record<string, any> = {},
  ): Promise<void> {
    const spin = spinner('Generating file...').start();

    // Find project root and temporarily change to it
    const projectRoot = this.findProjectRoot();
    const originalCwd = process.cwd();

    try {
      // Temporarily change to project root for consistent path resolution
      process.chdir(projectRoot);

      // Normalize the name
      const className = this.toClassName(name);
      const fileName = this.toFileName(name);
      const variableName = this.toVariableName(name);

      // Build template variables
      const templateVars = {
        name: className + (options.suffix || ''),
        fileName,
        variableName,
        description: `Generated ${options.stubName}`,
        ...additionalVars,
      };

      // Read and render the stub
      const stubPath = path.join(this.stubsPath, `${options.stubName}.stub.ejs`);

      if (!fs.existsSync(stubPath)) {
        spin.fail();
        errorLog(`Stub file not found: ${stubPath}`);
        return;
      }

      const stubContent = fs.readFileSync(stubPath, 'utf-8');
      const rendered = ejs.render(stubContent, templateVars);

      // Ensure output directory exists
      // Use custom path if provided via --path option, prepend it to the default outputDir
      let targetDir: string;
      if (this.customPath) {
        // Strip 'src' or 'src/' prefix from outputDir when using custom path
        let relativeOutputDir = options.outputDir;
        if (relativeOutputDir === 'src') {
          relativeOutputDir = '';
        } else if (relativeOutputDir.startsWith('src/')) {
          relativeOutputDir = relativeOutputDir.slice(4);
        }
        targetDir = relativeOutputDir
          ? path.join(this.customPath, relativeOutputDir)
          : this.customPath;
      } else {
        targetDir = options.outputDir;
      }
      const outputPath = path.join(process.cwd(), targetDir);
      if (!fs.existsSync(outputPath)) {
        fs.mkdirSync(outputPath, { recursive: true });
      }

      // Write the file
      const suffix = options.suffix ? `.${this.toFileName(options.suffix)}` : '';
      const outputFile = path.join(outputPath, `${fileName}${suffix}.ts`);

      if (fs.existsSync(outputFile)) {
        spin.fail();
        errorLog(`File already exists: ${outputFile}`);
        return;
      }

      fs.writeFileSync(outputFile, rendered);

      spin.succeed();
      success(`Created ${options.stubName}: ${outputFile}`);
    } catch (err: Error | any) {
      spin.fail();
      errorLog(`Failed to generate file: ${err.message}`);
    } finally {
      // Restore original cwd
      process.chdir(originalCwd);
    }
  }

  /**
   * Convert string to ClassName format (PascalCase)
   *
   * Transforms input strings into proper class names by capitalizing
   * the first letter of each word and removing separators.
   *
   * @param str - The string to convert
   * @returns PascalCase formatted string
   *
   * @example
   * toClassName('user-profile') // returns 'UserProfile'
   * toClassName('post_comment') // returns 'PostComment'
   * toClassName('Product') // returns 'Product'
   */
  protected toClassName(str: string): string {
    return str
      .split(/[-_]/)
      .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
      .join('');
  }

  /**
   * Convert string to file-name format (kebab-case)
   *
   * Transforms input strings into file-name format by converting
   * to lowercase and separating words with hyphens.
   *
   * @param str - The string to convert
   * @returns kebab-case formatted string
   *
   * @example
   * toFileName('UserProfile') // returns 'user-profile'
   * toFileName('PostComment') // returns 'post-comment'
   */
  protected toFileName(str: string): string {
    return str
      .replace(/([A-Z])/g, '-$1')
      .toLowerCase()
      .replace(/^-/, '');
  }

  /**
   * Convert string to variableName format (camelCase)
   *
   * Transforms input strings into proper variable names by converting
   * to camelCase format.
   *
   * @param str - The string to convert
   * @returns camelCase formatted string
   *
   * @example
   * toVariableName('UserProfile') // returns 'userProfile'
   * toVariableName('post-comment') // returns 'postComment'
   */
  protected toVariableName(str: string): string {
    const className = this.toClassName(str);
    return className.charAt(0).toLowerCase() + className.slice(1);
  }

  /**
   * Convert string to kebab-case format.
   *
   * Transforms input strings into kebab-case by converting to lowercase
   * and separating words with hyphens. This is an alias for toFileName
   * for clarity when the output isn't specifically a file name.
   *
   * @param str - The string to convert
   * @returns kebab-case formatted string
   *
   * @example
   * toKebabCase('UserProfile') // returns 'user-profile'
   * toKebabCase('postComment') // returns 'post-comment'
   * toKebabCase('API_KEY') // returns 'api-key'
   */
  protected toKebabCase(str: string): string {
    return this.toFileName(str);
  }

  /**
   * Convert string to snake_case format.
   *
   * Transforms input strings into snake_case by converting to lowercase
   * and separating words with underscores. Commonly used for database
   * column names, environment variables, or constants.
   *
   * @param str - The string to convert
   * @returns snake_case formatted string
   *
   * @example
   * toSnakeCase('UserProfile') // returns 'user_profile'
   * toSnakeCase('postComment') // returns 'post_comment'
   * toSnakeCase('API-KEY') // returns 'api_key'
   */
  protected toSnakeCase(str: string): string {
    return str
      .replace(/([A-Z])/g, '_$1')
      .toLowerCase()
      .replace(/^_/, '')
      .replace(/-/g, '_');
  }

  /**
   * Convert string to CONSTANT_CASE format.
   *
   * Transforms input strings into CONSTANT_CASE by converting to uppercase
   * and separating words with underscores. Used for constants, environment
   * variables, and enum values.
   *
   * @param str - The string to convert
   * @returns CONSTANT_CASE formatted string
   *
   * @example
   * toConstantCase('userProfile') // returns 'USER_PROFILE'
   * toConstantCase('post-comment') // returns 'POST_COMMENT'
   * toConstantCase('api_key') // returns 'API_KEY'
   */
  protected toConstantCase(str: string): string {
    return this.toSnakeCase(str).toUpperCase();
  }

  /**
   * Convert string to PascalCase format.
   *
   * This is an alias for toClassName for clarity when the output
   * isn't specifically a class name but needs PascalCase formatting.
   *
   * @param str - The string to convert
   * @returns PascalCase formatted string
   *
   * @example
   * toPascalCase('user-profile') // returns 'UserProfile'
   * toPascalCase('post_comment') // returns 'PostComment'
   */
  protected toPascalCase(str: string): string {
    return this.toClassName(str);
  }

  /**
   * Convert string to camelCase format.
   *
   * This is an alias for toVariableName for clarity when the output
   * isn't specifically a variable name but needs camelCase formatting.
   *
   * @param str - The string to convert
   * @returns camelCase formatted string
   *
   * @example
   * toCamelCase('user-profile') // returns 'userProfile'
   * toCamelCase('PostComment') // returns 'postComment'
   */
  protected toCamelCase(str: string): string {
    return this.toVariableName(str);
  }

  /**
   * Convert string to Title Case format.
   *
   * Transforms input strings into Title Case by capitalizing the first
   * letter of each word and separating with spaces. Useful for display
   * names, titles, and human-readable labels.
   *
   * @param str - The string to convert
   * @returns Title Case formatted string
   *
   * @example
   * toTitleCase('user-profile') // returns 'User Profile'
   * toTitleCase('postComment') // returns 'Post Comment'
   * toTitleCase('API_KEY') // returns 'Api Key'
   */
  protected toTitleCase(str: string): string {
    return str
      .split(/[-_]/) // Split on hyphens and underscores
      .map((part) => {
        // Handle camelCase by inserting spaces before capitals
        return part
          .replace(/([A-Z])/g, ' $1')
          .trim()
          .split(' ')
          .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
          .join(' ');
      })
      .join(' ');
  }

  /**
   * Get relative path from one directory to another
   *
   * Calculates the relative path between two directories and normalizes
   * separators to forward slashes.
   *
   * @param from - Source directory path
   * @param to - Target directory path
   * @returns Relative path with forward slashes
   *
   * @example
   * getRelativePath('src/services', 'src/entities') // returns '../entities'
   */
  protected getRelativePath(from: string, to: string): string {
    return path.relative(from, to).replace(/\\/g, '/');
  }
}
