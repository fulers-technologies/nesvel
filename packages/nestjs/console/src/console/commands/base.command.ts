import { Injectable, OnModuleInit } from '@nestjs/common';
import { CommandRunner } from 'nest-commander';

/**
 * Base Command
 *
 * Abstract base class providing common functionality for all CLI commands.
 * Provides command execution utilities like call() and callSilent() similar
 * to Symfony and Laravel console commands.
 *
 * @description Provides command execution utilities for calling other commands
 * @author Generated by @nesvel/nestjs-console
 *
 * @example
 * ```typescript
 * @Command({
 *   name: 'my:command',
 *   description: 'My custom command',
 * })
 * export class MyCommand extends BaseCommand {
 *   async run(): Promise<void> {
 *     await this.call('make:model', ['User']);
 *   }
 * }
 * ```
 */
@Injectable()
export abstract class BaseCommand extends CommandRunner {
  /**
   * Map of registered commands by name
   */
  private static commandMap = new Map<string, CommandRunner>();

  constructor() {
    super();
    // Auto-register this command by reading its decorator metadata
    this.registerSelf();
  }

  /**
   * Auto-register this command instance using decorator metadata
   */
  private registerSelf() {
    // nest-commander uses 'CommandBuilder:Command:Meta' as the metadata key
    const metadata = Reflect.getMetadata('CommandBuilder:Command:Meta', this.constructor);

    if (metadata?.name) {
      BaseCommand.commandMap.set(metadata.name, this);
    }
  }

  /**
   * Register a command instance manually (for testing or special cases)
   */
  static registerCommand(name: string, instance: CommandRunner) {
    BaseCommand.commandMap.set(name, instance);
  }

  /**
   * Abstract method that must be implemented by all concrete command classes
   *
   * @param inputs - Command arguments
   * @param options - Command options
   */
  abstract run(inputs?: string[], options?: Record<string, any>): Promise<void>;

  /**
   * Check if a command is registered
   *
   * @param commandName - The name of the command to check
   * @returns True if the command is registered, false otherwise
   *
   * @example
   * ```typescript
   * if (this.commandExists('make:model')) {
   *   await this.call('make:model', ['User']);
   * }
   * ```
   */
  protected commandExists(commandName: string): boolean {
    return BaseCommand.commandMap.has(commandName);
  }

  /**
   * Call another command by name
   *
   * Executes another command with the given arguments and options,
   * showing output to the user (similar to Symfony/Laravel's call method).
   *
   * If the command is registered in the command map, it will be executed
   * via executeCommand(). Otherwise, it will attempt to execute it as a
   * shell command (e.g., for delegating to external CLIs like MikroORM).
   *
   * @param commandName - The name of the command to execute
   * @param args - Array of arguments and options to pass to the command
   * @returns Promise that resolves when the command completes
   *
   * @example
   * ```typescript
   * // Call registered command
   * await this.call('make:model', ['User']);
   *
   * // Call external CLI command (e.g., MikroORM)
   * await this.call('bun', ['orm', 'migration:up']);
   * ```
   */
  protected async call(commandName: string, args: string[] = []): Promise<void> {
    if (this.commandExists(commandName)) {
      await this.executeCommand(commandName, args, false);
    } else {
      // Fallback to shell execution for external commands
      await this.shell(commandName, args, { silent: false });
    }
  }

  /**
   * Call another command silently
   *
   * Executes another command with the given arguments and options,
   * suppressing all output (similar to Symfony/Laravel's callSilent method).
   *
   * If the command is registered in the command map, it will be executed
   * via executeCommand(). Otherwise, it will attempt to execute it as a
   * shell command with output suppressed.
   *
   * @param commandName - The name of the command to execute
   * @param args - Array of arguments and options to pass to the command
   * @returns Promise that resolves when the command completes
   *
   * @example
   * ```typescript
   * // Call registered command silently
   * await this.callSilent('make:model', ['User']);
   *
   * // Call external CLI command silently
   * await this.callSilent('bun', ['orm', 'migration:up']);
   * ```
   */
  protected async callSilent(commandName: string, args: string[] = []): Promise<void> {
    if (this.commandExists(commandName)) {
      await this.executeCommand(commandName, args, true);
    } else {
      // Fallback to shell execution for external commands (silent)
      await this.shell(commandName, args, { silent: true });
    }
  }

  /**
   * Execute a command with or without output suppression
   *
   * This method assumes the command exists in the command map.
   * Use commandExists() to check before calling this method.
   *
   * @private
   * @param commandName - The name of the command to execute
   * @param args - Array of arguments and options to pass to the command
   * @param silent - Whether to suppress output
   */
  private async executeCommand(
    commandName: string,
    args: string[] = [],
    silent: boolean = false
  ): Promise<void> {
    // Get command from the registered command map
    const commandInstance = BaseCommand.commandMap.get(commandName);

    // This should not happen as call() and callSilent() check existence first
    if (!commandInstance) {
      throw new Error(
        `Command not found: ${commandName}. This is likely a bug - the command should have been checked for existence.`
      );
    }

    // Parse arguments and options
    const { inputs, options } = this.parseArgs(args);

    // Save original customPath and set new one if provided
    // This mimics what the @Option decorator would do
    let customPathWasSet = false;
    const originalCustomPath = (commandInstance as any).customPath;

    if (options.path) {
      (commandInstance as any).customPath = options.path;
      customPathWasSet = true;
    }

    // Suppress console output if silent
    const originalLog = console.log;
    const originalError = console.error;
    const originalWarn = console.warn;
    const originalInfo = console.info;

    if (silent) {
      console.log = () => {};
      console.error = () => {};
      console.warn = () => {};
      console.info = () => {};
    }

    try {
      await commandInstance.run(inputs, options);
    } finally {
      // Restore original customPath only if we changed it
      if (customPathWasSet && 'customPath' in commandInstance) {
        (commandInstance as any).customPath = originalCustomPath;
      }
      // Restore console output
      if (silent) {
        console.log = originalLog;
        console.error = originalError;
        console.warn = originalWarn;
        console.info = originalInfo;
      }
    }
  }

  /**
   * Execute a shell command
   *
   * Useful for delegating to external CLI tools like MikroORM CLI.
   * Use this when you need to call commands that aren't registered
   * in the NestJS command system.
   *
   * @param command - The command to execute (e.g., 'bun', 'npx')
   * @param args - Array of arguments to pass to the command
   * @param options - Execution options
   * @returns Promise that resolves when the command completes
   *
   * @example
   * ```typescript
   * // Call MikroORM CLI
   * await this.shell('bun', ['orm', 'migration:up']);
   *
   * // Call with custom working directory
   * await this.shell('git', ['status'], { cwd: '/path/to/repo' });
   * ```
   */
  protected async shell(
    command: string,
    args: string[] = [],
    options: { cwd?: string; silent?: boolean } = {}
  ): Promise<{ stdout: string; stderr: string; exitCode: number }> {
    const { spawn } = await import('child_process');

    return new Promise((resolve, reject) => {
      const child = spawn(command, args, {
        cwd: options.cwd || process.cwd(),
        stdio: options.silent ? 'pipe' : 'inherit',
        shell: true,
      });

      let stdout = '';
      let stderr = '';

      if (options.silent) {
        child.stdout?.on('data', (data) => {
          stdout += data.toString();
        });

        child.stderr?.on('data', (data) => {
          stderr += data.toString();
        });
      }

      child.on('error', (error) => {
        reject(
          new Error(`Failed to execute command: ${command} ${args.join(' ')}\n${error.message}`)
        );
      });

      child.on('close', (code) => {
        if (code === 0) {
          resolve({ stdout, stderr, exitCode: code || 0 });
        } else {
          reject(
            new Error(
              `Command failed with exit code ${code}: ${command} ${args.join(' ')}\n${stderr}`
            )
          );
        }
      });
    });
  }

  /**
   * Parse arguments array into inputs and options
   *
   * @private
   * @param args - Array of arguments and options
   * @returns Object with inputs and options
   */
  private parseArgs(args: string[]): {
    inputs: string[];
    options: Record<string, any>;
  } {
    const inputs: string[] = [];
    const options: Record<string, any> = {};

    for (let i = 0; i < args.length; i++) {
      const arg = args[i];

      if (!arg) continue;

      if (arg.startsWith('--')) {
        // Long option
        const key = arg.slice(2);
        const nextArg = args[i + 1];

        if (nextArg && !nextArg.startsWith('-')) {
          options[key] = nextArg;
          i++;
        } else {
          options[key] = true;
        }
      } else if (arg.startsWith('-')) {
        // Short option
        const key = arg.slice(1);
        const nextArg = args[i + 1];

        if (nextArg && !nextArg.startsWith('-')) {
          options[key] = nextArg;
          i++;
        } else {
          options[key] = true;
        }
      } else {
        // Regular input
        inputs.push(arg);
      }
    }

    return { inputs, options };
  }
}
