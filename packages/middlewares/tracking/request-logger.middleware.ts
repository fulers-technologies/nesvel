import { Injectable, NestMiddleware, Logger } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

/**
 * Request Logger Middleware
 *
 * Comprehensive request/response logging with structured data for monitoring,
 * debugging, and audit trails. Logs include request IDs, timing, status codes,
 * user agents, and more.
 *
 * @description
 * Logs include:
 * - HTTP method and URL
 * - Request/Correlation/Trace IDs
 * - Client IP address
 * - User agent and device info
 * - Response status code
 * - Response time in milliseconds
 * - Request/response sizes
 * - Error details (if any)
 *
 * @features
 * - Structured JSON logging
 * - Request/response correlation
 * - Performance timing
 * - Client information tracking
 * - Error logging with stack traces
 * - Configurable log levels
 *
 * @author Generated by @nesvel/nestjs-orm
 * @since 1.0.0
 *
 * @example
 * ```typescript
 * // In app.module.ts
 * export class AppModule implements NestModule {
 *   configure(consumer: MiddlewareConsumer) {
 *     consumer
 *       .apply(RequestLoggerMiddleware)
 *       .forRoutes('*');
 *   }
 * }
 * ```
 *
 * @example Log output
 * ```json
 * {
 *   "timestamp": "2024-01-15T10:30:45.123Z",
 *   "method": "GET",
 *   "url": "/api/users",
 *   "statusCode": 200,
 *   "responseTime": 45,
 *   "requestId": "req-550e8400-e29b-41d4-a716-446655440000",
 *   "correlationId": "corr-12345",
 *   "ip": "192.168.1.100",
 *   "userAgent": "Mozilla/5.0..."
 * }
 * ```
 */
@Injectable()
export class RequestLoggerMiddleware implements NestMiddleware {
  /**
   * Logger instance for this middleware
   *
   * @private
   */
  private readonly logger = new Logger('HTTP');

  /**
   * Log incoming requests and responses
   *
   * @param req - Express request object
   * @param res - Express response object
   * @param next - Next function to call
   */
  use(req: Request, res: Response, next: NextFunction): void {
    // Record start time for response time calculation
    const startTime = Date.now();

    // Extract request metadata
    const requestData = {
      method: req.method,
      url: req.originalUrl || req.url,
      ip: this.getClientIp(req),
      userAgent: req.headers['user-agent'] || 'unknown',
      requestId: req.headers['x-request-id'],
      correlationId: req.headers['x-correlation-id'],
      traceId: req.headers['x-trace-id'],
    };

    // Log incoming request (optional, can be noisy)
    if (process.env.LOG_REQUESTS === 'true') {
      this.logger.log(`→ ${requestData.method} ${requestData.url}`, JSON.stringify(requestData));
    }

    // Hook into response finish event to log after response is sent
    res.on('finish', () => {
      // Calculate response time
      const responseTime = Date.now() - startTime;

      // Build log data
      const logData = {
        ...requestData,
        statusCode: res.statusCode,
        responseTime: `${responseTime}ms`,
        contentLength: res.get('content-length') || '0',
      };

      // Choose log level based on status code
      if (res.statusCode >= 500) {
        // Server errors - log as error
        this.logger.error(
          `← ${requestData.method} ${requestData.url} ${res.statusCode} ${responseTime}ms`,
          JSON.stringify(logData)
        );
      } else if (res.statusCode >= 400) {
        // Client errors - log as warning
        this.logger.warn(
          `← ${requestData.method} ${requestData.url} ${res.statusCode} ${responseTime}ms`,
          JSON.stringify(logData)
        );
      } else {
        // Success - log as info
        this.logger.log(
          `← ${requestData.method} ${requestData.url} ${res.statusCode} ${responseTime}ms`,
          JSON.stringify(logData)
        );
      }
    });

    // Log errors if they occur
    res.on('error', (error) => {
      this.logger.error(
        `✗ ${requestData.method} ${requestData.url} - Error`,
        error.stack,
        JSON.stringify({ ...requestData, error: error.message })
      );
    });

    next();
  }

  /**
   * Get client IP address
   * Handles proxies and load balancers
   *
   * @param req - Express request object
   * @returns Client IP address
   * @private
   */
  private getClientIp(req: Request): string {
    // Check X-Forwarded-For header (set by proxies)
    const forwardedFor = req.headers['x-forwarded-for'];

    if (forwardedFor) {
      const ips = Array.isArray(forwardedFor) ? forwardedFor[0] : forwardedFor;
      return (ips || '').split(',')[0].trim();
    }

    // Fall back to direct connection IP
    return req.ip || req.socket.remoteAddress || 'unknown';
  }
}
