import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

/**
 * Request Sanitizer Middleware
 *
 * Sanitizes user input to prevent NoSQL/SQL injection, XSS attacks,
 * and other malicious input. Cleans query parameters, body, and URL params.
 *
 * @description
 * This middleware protects against:
 * - NoSQL Injection (MongoDB operators like $where, $ne, etc.)
 * - SQL Injection attempts (though use parameterized queries primarily)
 * - XSS attacks (HTML/JavaScript injection)
 * - Path traversal attacks (../, ..\, etc.)
 * - NULL byte injection
 *
 * @features
 * - Removes MongoDB operators from input
 * - Strips HTML/script tags
 * - Encodes special characters
 * - Validates and sanitizes nested objects
 * - Configurable whitelist for allowed operators
 *
 * @author Generated by @nesvel/nestjs-orm
 * @since 1.0.0
 *
 * @example
 * ```typescript
 * // In app.module.ts
 * export class AppModule implements NestModule {
 *   configure(consumer: MiddlewareConsumer) {
 *     consumer
 *       .apply(RequestSanitizerMiddleware)
 *       .forRoutes('*');
 *   }
 * }
 * ```
 *
 * @example Attack prevention
 * ```typescript
 * // Before sanitization:
 * { email: { $ne: null }, password: { $regex: '.*' } }
 *
 * // After sanitization:
 * { email: '[removed]', password: '[removed]' }
 * ```
 *
 * @see https://owasp.org/www-project-web-security-testing-guide/
 */
@Injectable()
export class RequestSanitizerMiddleware implements NestMiddleware {
  /**
   * MongoDB operators to remove (NoSQL injection prevention)
   *
   * @private
   */
  private readonly mongoOperators = [
    '$where',
    '$ne',
    '$gt',
    '$gte',
    '$lt',
    '$lte',
    '$in',
    '$nin',
    '$regex',
    '$exists',
    '$type',
    '$mod',
    '$text',
    '$expr',
    '$jsonSchema',
    '$all',
    '$elemMatch',
    '$size',
  ];

  /**
   * Patterns that indicate potential attacks
   *
   * @private
   */
  private readonly dangerousPatterns = [
    /\$\{.*\}/g, // Template literal injection
    /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, // Script tags
    /javascript:/gi, // JavaScript protocol
    /on\w+\s*=/gi, // Event handlers
    /\.\.\/|\.\.\\/g, // Path traversal
    new RegExp('\\0', 'g'), // NULL bytes
  ];

  /**
   * Sanitize incoming requests
   *
   * @param req - Express request object
   * @param res - Express response object
   * @param next - Next function to call
   */
  use(req: Request, res: Response, next: NextFunction): void {
    // Sanitize request body (POST/PUT/PATCH data)
    if (req.body && typeof req.body === 'object') {
      const sanitized = this.sanitizeObject(req.body);
      req.body = sanitized as Record<string, unknown>;
    }

    // Sanitize query parameters (GET query string)
    if (req.query && typeof req.query === 'object') {
      const sanitized = this.sanitizeObject(req.query);
      req.query = sanitized as Record<string, unknown>;
    }

    // Sanitize URL parameters (route params like /users/:id)
    if (req.params && typeof req.params === 'object') {
      const sanitized = this.sanitizeObject(req.params);
      req.params = sanitized as Record<string, unknown>;
    }

    next();
  }

  /**
   * Recursively sanitize an object
   *
   * @param obj - Object to sanitize
   * @returns Sanitized object
   * @private
   */
  private sanitizeObject<T>(
    obj: T
  ): T extends string
    ? string
    : T extends Array<infer U>
      ? Array<U>
      : T extends object
        ? Record<string, unknown>
        : T {
    // Handle null/undefined
    if (obj === null || obj === undefined) {
      return obj as never;
    }

    // Handle arrays
    if (Array.isArray(obj)) {
      return obj.map((item: unknown) => this.sanitizeObject(item)) as never;
    }

    // Handle objects
    if (typeof obj === 'object') {
      const sanitized: Record<string, unknown> = {};

      for (const [key, value] of Object.entries(obj as Record<string, unknown>)) {
        // Remove MongoDB operators
        if (this.mongoOperators.includes(key)) {
          sanitized[key] = '[removed]';
          continue;
        }

        // Sanitize key (prevent prototype pollution)
        const safeKey = this.sanitizeString(key);

        // Recursively sanitize nested objects
        if (typeof value === 'object') {
          sanitized[safeKey] = this.sanitizeObject(value);
        }
        // Sanitize string values
        else if (typeof value === 'string') {
          sanitized[safeKey] = this.sanitizeString(value);
        }
        // Keep other types as-is (numbers, booleans)
        else {
          sanitized[safeKey] = value;
        }
      }

      return sanitized as never;
    }

    // Handle strings
    if (typeof obj === 'string') {
      return this.sanitizeString(obj) as never;
    }

    // Return other primitives as-is
    return obj as never;
  }

  /**
   * Sanitize a string value
   *
   * @param str - String to sanitize
   * @returns Sanitized string
   * @private
   */
  private sanitizeString(str: string): string {
    // Remove dangerous patterns
    let sanitized = str;

    for (const pattern of this.dangerousPatterns) {
      sanitized = sanitized.replace(pattern, '');
    }

    // Trim whitespace
    sanitized = sanitized.trim();

    // Prevent prototype pollution
    if (sanitized === '__proto__' || sanitized === 'constructor' || sanitized === 'prototype') {
      return '[removed]';
    }

    return sanitized;
  }
}
