import { Command, Group } from '@nesvel/nestjs-console';
import { CommandRunner, Option } from 'nest-commander';
import { MikroORM } from '@mikro-orm/core';
import { Injectable, Logger } from '@nestjs/common';

/**
 * Migrate Rollback Command
 *
 * Rolls back the last batch of migrations.
 * Similar to Laravel's `php artisan migrate:rollback`.
 *
 * @description CLI command for rolling back migrations
 * @author Generated by @nesvel/nestjs-orm
 *
 * @example
 * ```bash
 * # Rollback the last batch of migrations
 * npm run console migrate:rollback
 *
 * # Rollback specific number of migrations
 * npm run console migrate:rollback --step=2
 *
 * # Dry run
 * npm run console migrate:rollback --dry-run
 * ```
 */
@Injectable()
@Command({
  name: 'migrate:rollback',
  description: 'Rollback the last batch of database migrations',
})
@Group('Database Migrations')
export class MigrateRollbackCommand extends CommandRunner {
  private readonly logger = new Logger(MigrateRollbackCommand.name);

  constructor(private readonly orm: MikroORM) {
    super();
  }

  async run(inputs: string[], options?: MigrateRollbackOptions): Promise<void> {
    try {
      const migrator = this.orm.getMigrator();

      this.logger.log('Rolling back migrations...');

      if (options?.dryRun) {
        this.logger.log('DRY RUN MODE - No changes will be made');
      }

      // Get executed migrations
      const executed = await migrator.getExecutedMigrations();

      if (executed.length === 0) {
        this.logger.log('✅ No migrations to rollback');
        return;
      }

      this.logger.log(`Found ${executed.length} executed migration(s)`);

      // Rollback migrations
      const result = await migrator.down({
        ...(options?.dryRun && { dryRun: true }),
        ...(options?.step && { to: options.step }),
      });

      if (options?.dryRun) {
        this.logger.log('\nSQL that would be executed:');
        if (result.length > 0) {
          result.forEach((migration: any) => {
            this.logger.log(`\n=== ${migration.name} ===`);
            if (migration.sql) {
              const sqlStatements = Array.isArray(migration.sql) ? migration.sql : [migration.sql];
              sqlStatements.forEach((sql: string) => this.logger.log(sql));
            }
          });
        }
      } else {
        this.logger.log(`\n✅ Successfully rolled back ${result.length} migration(s)`);
        result.forEach((migration) => {
          this.logger.log(`  ✓ ${migration.name}`);
        });
      }
    } catch (error: any) {
      this.logger.error('❌ Rollback failed:', error.message);
      throw error;
    }
  }

  // @ts-ignore - nest-commander decorator signature mismatch
  @Option({
    flags: '--dry-run',
    description: 'Run rollback in dry-run mode (show SQL without executing)',
  })
  parseDryRun(): boolean {
    return true;
  }

  // @ts-ignore - nest-commander decorator signature mismatch
  @Option({
    flags: '--step <number>',
    description: 'Number of migrations to rollback',
  })
  parseStep(val: string): number {
    return parseInt(val, 10);
  }
}

interface MigrateRollbackOptions {
  dryRun?: boolean;
  step?: number;
}
