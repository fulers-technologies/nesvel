import { Command, CommandRunner, Option } from 'nest-commander';
import { MikroORM } from '@mikro-orm/core';
import { Injectable, Logger } from '@nestjs/common';

/**
 * Migrate Command
 *
 * Runs all pending database migrations using MikroORM's migration system.
 * Similar to Laravel's `php artisan migrate`.
 *
 * @description CLI command for running database migrations
 * @author Generated by @nesvel/nestjs-orm
 *
 * @example
 * ```bash
 * # Run all pending migrations
 * npm run console migrate
 *
 * # Run migrations with transaction wrapping (default)
 * npm run console migrate --transaction
 *
 * # Run migrations without transactions
 * npm run console migrate --no-transaction
 *
 * # Dry run (show what would be executed)
 * npm run console migrate --dry-run
 * ```
 */
@Injectable()
@Command({
  name: 'migrate',
  description: 'Run pending database migrations',
})
export class MigrateCommand extends CommandRunner {
  private readonly logger = new Logger(MigrateCommand.name);

  constructor(private readonly orm: MikroORM) {
    super();
  }

  async run(inputs: string[], options?: MigrateOptions): Promise<void> {
    try {
      const migrator = this.orm.getMigrator();

      this.logger.log('Running migrations...');

      if (options?.dryRun) {
        this.logger.log('DRY RUN MODE - No changes will be made');
      }

      // Get pending migrations
      const pending = await migrator.getPendingMigrations();

      if (pending.length === 0) {
        this.logger.log('✅ No pending migrations');
        return;
      }

      this.logger.log(`Found ${pending.length} pending migration(s):`);
      pending.forEach((migration) => {
        this.logger.log(`  - ${migration.name}`);
      });

      // Run migrations
      const result = await migrator.up({
        transaction: options?.transaction,
        ...(options?.dryRun && { dryRun: true }),
      });

      if (options?.dryRun) {
        this.logger.log('\nSQL that would be executed:');
        if (result.length > 0) {
          result.forEach((migration: any) => {
            this.logger.log(`\n=== ${migration.name} ===`);
            if (migration.sql) {
              const sqlStatements = Array.isArray(migration.sql) ? migration.sql : [migration.sql];
              sqlStatements.forEach((sql: string) => this.logger.log(sql));
            }
          });
        }
      } else {
        this.logger.log(`\n✅ Successfully ran ${result.length} migration(s)`);
        result.forEach((migration) => {
          this.logger.log(`  ✓ ${migration.name}`);
        });
      }
    } catch (error: any) {
      this.logger.error('❌ Migration failed:', error.message);
      throw error;
    }
  }

  // @ts-ignore - nest-commander decorator signature mismatch
  @Option({
    flags: '--dry-run',
    description: 'Run migrations in dry-run mode (show SQL without executing)',
  })
  parseDryRun(): boolean {
    return true;
  }

  // @ts-ignore - nest-commander decorator signature mismatch
  @Option({
    flags: '--transaction',
    description: 'Wrap migrations in a transaction (default: true)',
    defaultValue: true,
  })
  parseTransaction(): boolean {
    return true;
  }

  // @ts-ignore - nest-commander decorator signature mismatch
  @Option({
    flags: '--no-transaction',
    description: 'Do not wrap migrations in a transaction',
  })
  parseNoTransaction(): boolean {
    return false;
  }
}

interface MigrateOptions {
  dryRun?: boolean;
  transaction?: boolean;
}
