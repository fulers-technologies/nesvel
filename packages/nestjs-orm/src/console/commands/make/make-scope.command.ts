import { Command } from '@nesvel/nestjs-console';
import { BaseOrmMakeCommand } from '../base-orm-make.command';

/**
 * Make Scope Command
 *
 * Generates a new query scope class for creating reusable, chainable query
 * constraints. Scopes allow you to encapsulate common query patterns and
 * make your code more maintainable and expressive.
 *
 * Query scopes are useful for:
 * - Filtering records by common criteria (active users, published posts)
 * - Applying complex where clauses consistently
 * - Implementing soft delete queries
 * - Date range filtering (recent, old, between dates)
 * - Status-based filtering
 * - Permission and visibility constraints
 * - Sorting and ordering patterns
 *
 * Scopes can be chained together and combined with other query methods
 * for maximum flexibility.
 *
 * @description CLI command for generating query scope classes
 * @author Generated by @nesvel/nestjs-orm
 * @since 1.0.0
 *
 * @example
 * ```bash
 * # Generate an ActiveScope for filtering active records
 * npm run console make:scope Active
 *
 * # Generate a PublishedScope for published content
 * npm run console make:scope Published
 *
 * # Generate a RecentScope for recent records
 * npm run console make:scope Recent
 * ```
 *
 * @example
 * ```typescript
 * // Generated scope can be used in repositories:
 * import { ActiveScope } from '@/scopes/active.scope';
 *
 * const activeUsers = await userRepository
 *   .createQueryBuilder()
 *   .where(new ActiveScope().apply())
 *   .getMany();
 * ```
 */
@Command({
  name: 'make:scope',
  arguments: '<name>',
  description: 'Create a new query scope class',
})
export class MakeScopeCommand extends BaseOrmMakeCommand {
  /**
   * Execute the make:scope command
   *
   * This method generates a new query scope class with:
   * - Injectable decorator for DI container
   * - apply() method that returns query constraints
   * - Proper typing for QueryBuilder
   * - Chainable interface for combining scopes
   * - Documentation and usage examples
   *
   * The generated file follows these conventions:
   * - File name: {name}.scope.ts (kebab-case)
   * - Class name: {Name}Scope (PascalCase)
   * - Location: src/scopes/
   * - Implements BaseScope interface
   *
   * The scope can accept constructor parameters for dynamic filtering:
   * - Date ranges
   * - Status values
   * - User context
   * - Permission levels
   *
   * @param inputs - Command arguments where first element is the scope name
   * @returns Promise that resolves when the file is created
   * @throws Error if scope name is not provided
   *
   * @example
   * ```typescript
   * // Running: npm run console make:scope Published
   * // Creates: src/scopes/published.scope.ts
   * //
   * // Generated scope can be applied to queries:
   * // .where(publishedScope.apply())
   * ```
   */
  async run(inputs: string[]): Promise<void> {
    // Extract scope name from command arguments
    const [name] = inputs;

    // Validate that scope name was provided
    if (!name) {
      throw new Error('Scope name argument is required.');
    }

    // Convert name to PascalCase for class name
    const className = this.toClassName(name);

    // Convert name to kebab-case for file name
    const fileName = this.toFileName(name);

    // Generate the scope file from template
    // The stub template should include:
    // - @Injectable() decorator
    // - apply() method returning FilterQuery
    // - Constructor for dynamic parameters
    // - Type-safe query constraints
    // - Usage examples in comments
    await this.generateFromStub(
      name,
      {
        stubName: 'scope',
        outputDir: 'src/scopes',
        suffix: 'scope',
      },
      {
        className,
        fileName,
      },
    );
  }
}
