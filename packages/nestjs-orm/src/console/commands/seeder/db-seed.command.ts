import { Command, CommandRunner, Option } from 'nest-commander';
import { Injectable, Logger } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import { EntityManager } from '@mikro-orm/core';
import { BaseSeeder } from '@/seeders/base.seeder';
import { FactoryManager } from '@/factories/factory.manager';
import { ISeederContext } from '@/interfaces';

/**
 * Database Seed Command
 *
 * Runs database seeders to populate the database with data.
 * Similar to Laravel's `php artisan db:seed`.
 *
 * @description CLI command for running database seeders
 * @author Generated by @nesvel/nestjs-orm
 *
 * @example
 * ```bash
 * # Run all seeders
 * npm run console db:seed
 *
 * # Run specific seeder
 * npm run console db:seed --class=UserSeeder
 *
 * # Run with verbose output
 * npm run console db:seed --verbose
 *
 * # Force run in production
 * npm run console db:seed --force
 * ```
 */
@Injectable()
@Command({
  name: 'db:seed',
  description: 'Seed the database with records',
})
export class DbSeedCommand extends CommandRunner {
  private readonly logger = new Logger(DbSeedCommand.name);

  constructor(
    private readonly moduleRef: ModuleRef,
    private readonly em: EntityManager,
    private readonly factoryManager: FactoryManager,
  ) {
    super();
  }

  async run(inputs: string[], options?: DbSeedOptions): Promise<void> {
    try {
      const environment = process.env.NODE_ENV || 'development';
      
      this.logger.log(`Seeding database in ${environment} environment...`);

      if (environment === 'production' && !options?.force) {
        this.logger.warn(
          '⚠️  Seeding in production is disabled. Use --force to override.',
        );
        return;
      }

      // Create seeder context
      const context: ISeederContext = {
        environment,
        args: {},
        verbose: options?.verbose ?? false,
        force: options?.force ?? false,
      };

      // If specific seeder class is specified
      if (options?.class) {
        await this.runSpecificSeeder(options.class, context);
      } else {
        await this.runAllSeeders(context);
      }

      this.logger.log('✅ Database seeding completed successfully');
    } catch (error: any) {
      this.logger.error('❌ Seeding failed:', error.message);
      throw error;
    }
  }

  /**
   * Run a specific seeder class
   */
  private async runSpecificSeeder(
    className: string,
    context: ISeederContext,
  ): Promise<void> {
    this.logger.log(`Running seeder: ${className}`);

    try {
      // Try to get the seeder from the module container
      const SeederClass = await this.getSeederClass(className);
      
      if (!SeederClass) {
        throw new Error(`Seeder ${className} not found`);
      }

      // Create seeder instance
      const seeder = new SeederClass(
        this.em,
        this.factoryManager,
        context,
      );

      // Execute the seeder
      const result = await seeder.execute();

      if (result.success) {
        this.logger.log(`✓ ${className} completed in ${result.executionTime}ms`);
      } else {
        this.logger.error(`✗ ${className} failed: ${result.error}`);
      }
    } catch (error: any) {
      this.logger.error(`Failed to run ${className}:`, error.message);
      throw error;
    }
  }

  /**
   * Run all registered seeders
   */
  private async runAllSeeders(context: ISeederContext): Promise<void> {
    this.logger.log('Running all seeders...');
    
    // Note: In a real implementation, you would:
    // 1. Scan for all seeder classes decorated with @Seeder
    // 2. Sort them by priority and dependencies
    // 3. Execute them in order
    
    this.logger.warn(
      '⚠️  Auto-discovery of seeders not yet implemented. Use --class to run specific seeders.',
    );
    
    // TODO: Implement seeder discovery and execution
    // This would require:
    // - A seeder registry service
    // - Metadata scanning for @Seeder decorated classes
    // - Dependency resolution and sorting
    // - Sequential execution with error handling
  }

  /**
   * Get seeder class by name
   */
  private async getSeederClass(className: string): Promise<any> {
    try {
      // Try to resolve from DI container
      return this.moduleRef.get(className, { strict: false });
    } catch {
      // If not in container, try dynamic import
      // This would require knowing the seeder file location
      this.logger.warn(`Could not find ${className} in DI container`);
      return null;
    }
  }

  // @ts-ignore - nest-commander decorator signature mismatch
  @Option({
    flags: '--class <className>',
    description: 'The name of the seeder class to run',
  })
  parseClass(val: string): string {
    return val;
  }

  // @ts-ignore - nest-commander decorator signature mismatch
  @Option({
    flags: '--force',
    description: 'Force the operation to run in production',
  })
  parseForce(): boolean {
    return true;
  }

  // @ts-ignore - nest-commander decorator signature mismatch
  @Option({
    flags: '--verbose',
    description: 'Enable verbose output',
  })
  parseVerbose(): boolean {
    return true;
  }
}

interface DbSeedOptions {
  class?: string;
  force?: boolean;
  verbose?: boolean;
}
