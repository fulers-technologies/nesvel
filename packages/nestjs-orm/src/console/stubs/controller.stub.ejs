import {
  Body,
  Param,
  Logger,
  Controller,
  UseInterceptors,
  ClassSerializerInterceptor,
} from '@nestjs/common';
import { ApiTags } from '@nesvel/nestjs-swagger';
import { Route, HttpMethod, EndpointPreset } from '@/decorators/route';
import {
  paginate,
  Paginate,
  Paginated,
  type PaginateQuery,
} from '@nesvel/nestjs-orm';

import { <%= modelName %> } from '@/entities/<%= fileName %>.entity';
import { <%= serviceName %> } from '@/services/<%= serviceFileName %>';
import { Create<%= modelName %>Dto } from '@/dtos/create-<%= fileName %>.dto';
import { Update<%= modelName %>Dto } from '@/dtos/update-<%= fileName %>.dto';

/**
 * <%= modelName %> Controller
 *
 * RESTful API controller for managing <%= modelName %> resources.
 * Provides full CRUD operations with OpenAPI documentation.
 *
 * Endpoints:
 * - GET    /<%= routePath %>       - List all <%= routePath %> with pagination
 * - GET    /<%= routePath %>/:id   - Get a single <%= fileName %> by ID
 * - POST   /<%= routePath %>       - Create a new <%= fileName %>
 * - PUT    /<%= routePath %>/:id   - Update an existing <%= fileName %> (full update)
 * - PATCH  /<%= routePath %>/:id   - Partially update a <%= fileName %>
 * - DELETE /<%= routePath %>/:id   - Delete a <%= fileName %>
 *
 * @description REST API controller for <%= modelName %> entity
 * @author Generated by @nesvel/nestjs-orm
 */
@ApiTags('<%= routePath %>')
@Controller('<%= routePath %>')
@UseInterceptors(ClassSerializerInterceptor)
export class <%= modelName %>Controller {
  /**
   * Logger instance for structured logging throughout the controller
   *
   * Automatically configured with the controller class name as context.
   * Uses NestJS Logger which supports different log levels and can be
   * configured for different environments (development, production, etc.)
   *
   * Log levels supported:
   * - error: Critical errors that need immediate attention
   * - warn: Warning messages for unexpected but non-critical situations
   * - log: General operational messages
   * - debug: Detailed information for debugging (disabled in production)
   * - verbose: Very detailed logging for development
   *
   * @protected
   * @readonly
   */
  protected readonly logger = new Logger(this.constructor.name);

  /**
   * Creates an instance of <%= modelName %>Controller
   *
   * @param <%= serviceVar %> - The <%= modelName %> service for business logic
   */
  constructor(private readonly <%= serviceVar %>: <%= serviceName %>) {}

  /**
   * List all <%= routePath %> with pagination, filtering, and search
   *
   * Retrieves a paginated list of <%= routePath %> with support for:
   * - Pagination via `page` and `limit` query parameters
   * - Sorting via `sortBy` query parameter
   * - Searching via `search` query parameter
   * - Filtering via `filter` query parameters
   *
   * @param query - Pagination and filtering parameters from @Paginate() decorator
   * @returns Paginated list of <%= routePath %> with metadata
   *
   * @example
   * GET /<%= routePath %>?page=1&limit=20&sortBy=createdAt:DESC&search=keyword
   */
  @Route({
    preset: EndpointPreset.CRUD_LIST,
    auth: {
      bearer: true,
    },
    documentation: {
      summary: 'List all <%= routePath %>',
      description:
        'Retrieves a paginated list of <%= routePath %> with optional filtering, sorting, and search capabilities',
      tags: ['<%= routePath %>', 'crud'],
    },
    responses: {
      ok: {
        description: '<%= modelName %> records retrieved successfully',
        type: [<%= modelName %>],
      },
      unauthorized: 'Authentication required',
      forbidden: 'Insufficient permissions',
    },
    cache: {
      enabled: true,
      key: '<%= routePath %>:list:{{page}}:{{limit}}',
      ttl: 60, // Cache for 60 seconds
    },
  })
  async findAll(@Paginate() query: PaginateQuery): Promise<Paginated<<%= modelName %>>> {
    this.logger.log(`Fetching <%= routePath %> with query: ${JSON.stringify(query)}`);

    // Use the pagination builder for a fluent API
    return await paginate(this.<%= serviceVar %>.getRepository(), query)
      .withSortables(['id', 'createdAt', 'updatedAt'])
      .withSearchables([/* Add searchable fields here, e.g., 'name', 'email' */])
      .withDefaultLimit(20)
      .withMaxLimit(100)
      .execute();
  }

  /**
   * Get a single <%= fileName %> by ID
   *
   * Retrieves detailed information about a specific <%= fileName %> identified by its
   * unique ID. Returns 404 if the <%= fileName %> is not found.
   *
   * @param id - The unique identifier of the <%= fileName %>
   * @returns The <%= fileName %> entity with all its data
   *
   * @example
   * GET /<%= routePath %>/123
   */
  @Route(':id', {
    auth: {
      bearer: true,
    },
    documentation: {
      summary: 'Get <%= fileName %> by ID',
      description: 'Retrieves detailed information about a specific <%= fileName %>',
      tags: ['<%= routePath %>', 'crud'],
    },
    params: [
      {
        name: 'id',
        description: '<%= modelName %> unique identifier',
        type: Number,
        example: 123,
      },
    ],
    responses: {
      ok: {
        description: '<%= modelName %> found successfully',
        type: <%= modelName %>,
      },
      notFound: '<%= modelName %> not found with the specified ID',
      unauthorized: 'Authentication required',
    },
    cache: {
      enabled: true,
      key: '<%= fileName %>:{{id}}',
      ttl: 300, // Cache for 5 minutes
    },
  })
  async findOne(@Param('id') id: string) {
    this.logger.log(`Fetching <%= fileName %> with ID: ${id}`);

    return await this.<%= serviceVar %>.findOneOrFail(parseInt(id, 10));
  }

  /**
   * Create a new <%= fileName %>
   *
   * Creates a new <%= fileName %> with the provided data. The request body is validated
   * against the Create<%= modelName %>Dto schema. Returns the created <%= fileName %> with a 201
   * status code.
   *
   * @param create<%= modelName %>Dto - The <%= fileName %> data to create
   * @returns The newly created <%= fileName %> entity
   *
   * @example
   * POST /<%= routePath %>
   * Body: { "name": "Example", ... }
   */
  @Route({
    method: HttpMethod.POST,
    httpCode: 201,
    auth: {
      bearer: true,
    },
    body: Create<%= modelName %>Dto,
    documentation: {
      summary: 'Create a new <%= fileName %>',
      description: 'Creates a new <%= fileName %> with the provided information',
      tags: ['<%= routePath %>', 'crud'],
    },
    responses: {
      created: {
        description: '<%= modelName %> created successfully',
        type: <%= modelName %>,
        headers: {
          Location: {
            description: 'URL of the newly created <%= fileName %>',
            schema: { type: 'string', format: 'uri' },
          },
        },
      },
      badRequest: {
        description: 'Invalid input data or validation failed',
      },
      unauthorized: 'Authentication required',
    },
    security: {
      rateLimit: {
        limit: 20,
        ttl: 60, // 20 requests per minute
      },
    },
    throttle: {
      limit: 10,
      ttl: 60, // 10 requests per minute per user
    },
  })
  async create(@Body() create<%= modelName %>Dto: Create<%= modelName %>Dto) {
    this.logger.log(`Creating new <%= fileName %>: ${JSON.stringify(create<%= modelName %>Dto)}`);

    return await this.<%= serviceVar %>.create(create<%= modelName %>Dto);
  }

  /**
   * Update an existing <%= fileName %> (full update)
   *
   * Updates all fields of an existing <%= fileName %>. This is a full replacement of the
   * <%= fileName %> data. For partial updates, use the PATCH endpoint instead.
   *
   * @param id - The unique identifier of the <%= fileName %> to update
   * @param update<%= modelName %>Dto - The complete <%= fileName %> data for update
   * @returns The updated <%= fileName %> entity
   *
   * @example
   * PUT /<%= routePath %>/123
   * Body: { "name": "Updated Example", ... }
   */
  @Route(':id', {
    method: HttpMethod.PUT,
    auth: {
      bearer: true,
    },
    body: Update<%= modelName %>Dto,
    documentation: {
      summary: 'Update a <%= fileName %>',
      description:
        'Performs a full update of an existing <%= fileName %> with the provided data',
      tags: ['<%= routePath %>', 'crud'],
    },
    params: [
      {
        name: 'id',
        description: '<%= modelName %> ID to update',
        type: Number,
        example: 123,
      },
    ],
    responses: {
      ok: {
        description: '<%= modelName %> updated successfully',
        type: <%= modelName %>,
      },
      notFound: '<%= modelName %> not found with the specified ID',
      badRequest: 'Invalid update data or validation failed',
      unauthorized: 'Authentication required',
    },
    telemetry: {
      trace: true,
      metrics: true,
      spanName: '<%= fileName %>.update',
    },
  })
  async update(
    @Param('id') id: string,
    @Body() update<%= modelName %>Dto: Update<%= modelName %>Dto,
  ) {
    this.logger.log(`Updating <%= fileName %> ${id}: ${JSON.stringify(update<%= modelName %>Dto)}`);

    return await this.<%= serviceVar %>.update(parseInt(id, 10), update<%= modelName %>Dto);
  }

  /**
   * Partially update a <%= fileName %>
   *
   * Updates only the specified fields of an existing <%= fileName %>. This allows for
   * partial updates without needing to send the complete <%= fileName %> data.
   *
   * @param id - The unique identifier of the <%= fileName %> to update
   * @param update<%= modelName %>Dto - The partial <%= fileName %> data to update
   * @returns The updated <%= fileName %> entity
   *
   * @example
   * PATCH /<%= routePath %>/123
   * Body: { "name": "Updated Name" }
   */
  @Route(':id', {
    method: HttpMethod.PATCH,
    auth: {
      bearer: true,
    },
    body: Update<%= modelName %>Dto,
    documentation: {
      summary: 'Partially update a <%= fileName %>',
      description:
        'Updates specific fields of an existing <%= fileName %> without requiring all fields',
      tags: ['<%= routePath %>', 'crud'],
    },
    params: [
      {
        name: 'id',
        description: '<%= modelName %> ID to partially update',
        type: Number,
        example: 123,
      },
    ],
    responses: {
      ok: {
        description: '<%= modelName %> updated successfully',
        type: <%= modelName %>,
      },
      notFound: '<%= modelName %> not found with the specified ID',
      badRequest: 'Invalid patch data or validation failed',
      unauthorized: 'Authentication required',
    },
    circuitBreaker: {
      threshold: 5,
      timeout: 3000,
    },
    retry: {
      attempts: 3,
      delay: 1000,
    },
  })
  async patch(
    @Param('id') id: string,
    @Body() update<%= modelName %>Dto: Partial<Update<%= modelName %>Dto>,
  ) {
    this.logger.log(`Patching <%= fileName %> ${id}: ${JSON.stringify(update<%= modelName %>Dto)}`);

    return await this.<%= serviceVar %>.update(
      parseInt(id, 10),
      update<%= modelName %>Dto as Update<%= modelName %>Dto,
    );
  }

  /**
   * Delete a <%= fileName %>
   *
   * Permanently removes a <%= fileName %> from the system. This action cannot be undone.
   * Returns 204 No Content on successful deletion.
   *
   * @param id - The unique identifier of the <%= fileName %> to delete
   * @returns Success message or 204 No Content
   *
   * @example
   * DELETE /<%= routePath %>/123
   */
  @Route(':id', {
    preset: EndpointPreset.CRUD_DELETE,
    auth: {
      bearer: true,
    },
    roles: ['admin', 'manager'], // Only admins and managers can delete <%= routePath %>
    documentation: {
      summary: 'Delete a <%= fileName %>',
      description:
        'Permanently removes a <%= fileName %> from the system. This action is irreversible.',
      tags: ['<%= routePath %>', 'crud'],
    },
    params: [
      {
        name: 'id',
        description: '<%= modelName %> ID to delete',
        type: Number,
        example: 123,
      },
    ],
    responses: {
      ok: {
        description: '<%= modelName %> deleted successfully',
        schema: {
          type: 'object',
          properties: {
            message: { type: 'string', example: '<%= modelName %> deleted successfully' },
            id: { type: 'number', example: 123 },
          },
        },
      },
      notFound: '<%= modelName %> not found with the specified ID',
      forbidden: 'Only admins and managers can delete <%= routePath %>',
      unauthorized: 'Authentication required',
    },
  })
  async remove(@Param('id') id: string) {
    this.logger.log(`Deleting <%= fileName %> with ID: ${id}`);
    await this.<%= serviceVar %>.delete(parseInt(id, 10));

    return {
      message: '<%= modelName %> deleted successfully',
      id: parseInt(id, 10),
    };
  }
}
