import { Injectable, Inject } from '@nestjs/common';
import { PubSubService } from '@nesvel/nestjs-pubsub';
import { BaseSubscriber } from '@nesvel/nestjs-orm';
import { <%= entityName %> } from '@/entities/<%= fileName %>';

/**
 * <%= className %>
 *
 * Entity subscriber for <%= entityName %> lifecycle events.
 * Extends BaseSubscriber to automatically publish entity events to PubSub.
 *
 * This subscriber listens to <%= entityName %> entity lifecycle events and publishes
 * them to the PubSub system for consumption by other services. It inherits all
 * functionality from BaseSubscriber including:
 * - Automatic event publishing on create, update, delete
 * - Change tracking with before/after values
 * - Performance metrics (optional)
 * - Configurable channel naming patterns
 * - Sensitive data sanitization
 *
 * Published Events:
 * - <%= fileName %>.created - When a new <%= entityName %> is created
 * - <%= fileName %>.updated - When an existing <%= entityName %> is updated
 * - <%= fileName %>.deleted - When a <%= entityName %> is hard deleted
 * - <%= fileName %>.soft_deleted - When a <%= entityName %> is soft deleted
 * - <%= fileName %>.loaded - When a <%= entityName %> is loaded (if enabled)
 *
 * @description Subscribes to and publishes <%= entityName %> entity events
 * @author Generated by @nesvel/nestjs-orm
 * @since 1.0.0
 *
 * @example
 * ```typescript
 * // Register in module:
 * @Module({
 *   providers: [<%= className %>],
 * })
 * export class AppModule {}
 *
 * // Listen to events in another service:
 * this.pubsub.subscribe('<%= fileName %>.created', (payload) => {
 *   console.log('New <%= entityName %> created:', payload.entityId);
 *   // Send notification, update cache, etc.
 * });
 * ```
 */
@Injectable()
export class <%= className %> extends BaseSubscriber<<%= entityName %>> {
  /**
   * Constructor for <%= className %>
   *
   * Injects the PubSub service and configures subscriber options.
   * The parent BaseSubscriber handles all event publishing logic.
   *
   * @param pubsub - PubSub service for event publishing
   */
  constructor(@Inject('PUBSUB_SERVICE') pubsub: PubSubService) {
    super(pubsub, {
      enabled: true, // Enable event publishing
      includePerformanceMetrics: false, // Disable performance tracking
      trackDetailedChanges: true, // Enable change tracking for updates
      channelPattern: '{entityName}.{operation}', // Simple channel naming
      logEvents: false, // Disable logging to prevent spam
      publishLoadEvents: false, // Don't publish load events
    });
  }

  /**
   * Get the entities this subscriber listens to
   *
   * Returns an array containing the <%= entityName %> entity class.
   * Only events from <%= entityName %> entities will trigger this subscriber.
   *
   * @returns Array containing <%= entityName %> entity class
   */
  getSubscribedEntities(): any[] {
    return [<%= entityName %>];
  }

  // ============================================================================
  // Custom Event Handlers (Optional Overrides)
  // ============================================================================
  //
  // You can override BaseSubscriber methods to add custom logic AFTER the
  // base event publishing happens. The base methods automatically publish
  // events to PubSub, so you only need to override if you need additional
  // custom behavior specific to this entity.
  //
  // Example: Override afterCreate to add custom logging or side effects
  //
  // async afterCreate(args: EventArgs<<%= entityName %>>): Promise<void> {
  //   // Call parent to publish the event
  //   await super.afterCreate(args);
  //   
  //   // Add custom logic here
  //   const entity = args.entity;
  //   this.logger.log(`Custom logic after creating <%= entityName %>: ${entity.id}`);
  //   
  //   // TODO: Add custom post-creation logic
  //   // Examples:
  //   // - Send custom notifications
  //   // - Update external systems
  //   // - Perform specific validations
  //   // - Create derived data
  // }
  //
  // Example: Override afterUpdate to react to specific field changes
  //
  // async afterUpdate(args: EventArgs<<%= entityName %>>): Promise<void> {
  //   // Call parent to publish the event with change tracking
  //   await super.afterUpdate(args);
  //   
  //   const entity = args.entity;
  //   
  //   // Access the __originalEntityData to check what changed
  //   const originalData = (entity as any).__originalEntityData;
  //   
  //   // TODO: Add custom post-update logic
  //   // Examples:
  //   // - React to specific field changes
  //   // - Send targeted notifications
  //   // - Update search indexes
  //   // - Cascade changes to related entities
  // }
  //
  // Example: Override afterDelete to add cleanup logic
  //
  // async afterDelete(args: EventArgs<<%= entityName %>>): Promise<void> {
  //   // Call parent to publish the event
  //   await super.afterDelete(args);
  //   
  //   const entity = args.entity;
  //   
  //   // TODO: Add custom post-deletion logic
  //   // Examples:
  //   // - Clean up file storage
  //   // - Remove from external services
  //   // - Cascade delete to related data
  //   // - Archive to backup system
  // }
  //
  // ============================================================================
  // Note: The BaseSubscriber already handles:
  // - Publishing events to PubSub on all lifecycle events
  // - Change tracking with before/after values on updates
  // - Sensitive data sanitization
  // - Performance metrics (if enabled)
  // - Error handling that won't break database operations
  //
  // You only need to override methods if you need ADDITIONAL custom behavior
  // beyond the automatic event publishing provided by BaseSubscriber.
  // ============================================================================
}
