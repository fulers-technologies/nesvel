import {
  UsePipes,
  UseGuards,
  SetMetadata,
  applyDecorators,
  UseInterceptors,
  UseFilters,
  HttpCode,
  Header,
  Redirect,
  Render,
  Version,
  Sse,
} from '@nestjs/common';
import { CacheInterceptor, CacheTTL, CacheKey } from '@nestjs/cache-manager';
import { Throttle } from '@nestjs/throttler';
import { ApiExcludeEndpoint } from '@nestjs/swagger';

import {
  buildApiBody,
  buildApiTags,
  buildApiParams,
  buildApiQueries,
  buildApiHeaders,
  buildApiConsumes,
  buildApiProduces,
  buildApiOperation,
} from './builders/swagger-docs.builder';
import { HttpMethod } from './enums/http-method.enum';
import { applyPreset } from './presets/preset-factory';
import { buildAuthDecorators } from './builders/auth.builder';
import { mergeWithDefaults } from './utils/merge-options.util';
import { DEFAULT_CONSUMES, DEFAULT_PRODUCES } from './constants';
import { autoGenerateDocs } from './utils/auto-generate-docs.util';
import { buildResponseDecorators } from './builders/response.builder';
import { RouteOptions } from './interfaces/api-endpoint-options.interface';
import { buildHttpMethodDecorator } from './builders/http-method.builder';
import {
  validateRouteOptions,
  validateCacheConfig,
  validateThrottleConfig,
} from './utils/validate-options.util';

// ============================================================================
// Decorator Result Caching for Performance
// ============================================================================

/**
 * Cache for storing built decorators to avoid rebuilding identical configurations.
 *
 * Uses WeakMap for automatic garbage collection when options objects are no longer referenced.
 * This prevents memory leaks while providing O(1) lookup performance.
 *
 * Note: Caching is based on object identity, not deep equality. Same configuration
 * object reused will hit cache, but identical configurations as separate objects won't.
 */
const decoratorCache = new WeakMap<RouteOptions, MethodDecorator>();

/**
 * Comprehensive API endpoint decorator for NestJS applications.
 *
 * This decorator combines routing, authentication, caching, validation, documentation,
 * and various other configurations into a single, powerful decorator. It reduces
 * boilerplate and ensures consistency across API endpoints.
 *
 * Features:
 * - HTTP method routing (GET, POST, PUT, PATCH, DELETE, etc.)
 * - Automatic OpenAPI/Swagger documentation
 * - Authentication and authorization
 * - Request/response validation
 * - Caching configuration
 * - Rate limiting and throttling
 * - CORS configuration
 * - Circuit breaker patterns
 * - Retry policies
 * - File upload handling
 * - Preset configurations for common patterns
 * - Performance optimized with result caching
 *
 * @param options - Configuration options for the endpoint
 * @returns Composed decorator applying all specified configurations
 *
 * @example
 * Basic GET endpoint:
 * ```typescript
 * @Route({
 *   method: HttpMethod.GET,
 *   path: '/users',
 *   documentation: {
 *     summary: 'List all users',
 *     tags: ['users']
 *   }
 * })
 * async getUsers() {
 *   return this.userService.findAll();
 * }
 * ```
 *
 * @example
 * POST endpoint with authentication and validation:
 * ```typescript
 * @Route({
 *   method: HttpMethod.POST,
 *   path: '/users',
 *   auth: { bearer: true },
 *   body: CreateUserDto,
 *   responses: {
 *     created: { description: 'User created', type: UserDto },
 *     badRequest: 'Invalid data',
 *     unauthorized: 'Authentication required'
 *   }
 * })
 * async createUser(@Body() dto: CreateUserDto) {
 *   return this.userService.create(dto);
 * }
 * ```
 *
 * @example
 * Using a preset for common patterns:
 * ```typescript
 * @Route({
 *   preset: EndpointPreset.CRUD_LIST,
 *   path: '/products'
 * })
 * async listProducts() {
 *   return this.productService.findAll();
 * }
 * ```
 *
 * @example
 * File upload endpoint:
 * ```typescript
 * @Route({
 *   method: HttpMethod.POST,
 *   path: '/upload',
 *   file: {
 *     fieldName: 'file',
 *     maxCount: 1,
 *     limits: { fileSize: 5 * 1024 * 1024 }
 *   },
 *   consumes: ['multipart/form-data']
 * })
 * async uploadFile(@UploadedFile() file: Express.Multer.File) {
 *   return { filename: file.filename };
 * }
 * ```
 *
 * @example
 * Shorthand syntax with path first:
 * ```typescript
 * @Route(':id', {
 *   method: HttpMethod.GET,
 *   documentation: { summary: 'Get user by ID' }
 * })
 * async getUserById(@Param('id') id: string) {
 *   return this.userService.findById(id);
 * }
 * ```
 */

// Function overload: options only
export function Route<TBody = any>(
  options: RouteOptions<TBody>,
): MethodDecorator;

// Function overload: path first, then options
export function Route<TBody = any>(
  path: string | string[],
  options: Omit<RouteOptions<TBody>, 'path'>,
): MethodDecorator;

// Implementation signature
export function Route<TBody = any>(
  pathOrOptions?: string | string[] | RouteOptions<TBody>,
  maybeOptions?: Omit<RouteOptions<TBody>, 'path'>,
): MethodDecorator {
  // ========================================
  // 0. Resolve Function Overloads
  // ========================================
  // Handle both function signatures:
  // 1. Route(options) - single parameter as options object
  // 2. Route(path, options) - path as first parameter, options as second
  let options: RouteOptions<TBody>;

  if (!pathOrOptions) {
    // No arguments provided, use empty options
    options = (maybeOptions || {}) as RouteOptions<TBody>;
  } else if (
    typeof pathOrOptions === 'string' ||
    Array.isArray(pathOrOptions)
  ) {
    // First argument is a path (string or array), second is options
    options = {
      ...(maybeOptions || {}),
      path: pathOrOptions,
    } as RouteOptions<TBody>;
  } else {
    // First argument is the full options object
    options = pathOrOptions;
  }

  // ========================================
  // Performance: Check Decorator Cache
  // ========================================
  // Check if we've already built a decorator for these exact options
  // This is most effective when options object is reused (e.g., in constants)
  const cachedDecorator = decoratorCache.get(options);
  if (cachedDecorator) {
    return cachedDecorator;
  }

  // Array to collect all decorators to apply
  const decorators: Array<MethodDecorator | ClassDecorator> = [];

  // ========================================
  // 1. Apply Preset Configuration
  // ========================================
  let finalOptions = { ...options };

  if (options.preset) {
    // Merge preset defaults with user options
    const presetOptions = applyPreset(options.preset);
    finalOptions = mergeWithDefaults(presetOptions, options);
  }

  // ========================================
  // 2. Validate Options
  // ========================================
  // Validate for incompatible or conflicting options
  validateRouteOptions(finalOptions);

  // Validate specific configurations
  if (finalOptions.cache) {
    validateCacheConfig(finalOptions.cache);
  }

  if (finalOptions.throttle) {
    validateThrottleConfig(finalOptions.throttle);
  }

  // ========================================
  // 3. Extract Configuration Values
  // ========================================
  const {
    body,
    pipes,
    roles,
    auth,
    guards,
    params,
    queries,
    headers,
    exclude,
    version,
    metadata,
    httpCode,
    responses,
    path = '',
    interceptors,
    documentation,
    filters,
    redirect,
    render,
    sse,
    responseHeaders,
    method = HttpMethod.GET,
    consumes = DEFAULT_CONSUMES,
    produces = DEFAULT_PRODUCES,
  } = finalOptions;

  // ========================================
  // 4. HTTP Method Decorator
  // ========================================
  // Apply the HTTP method decorator (GET, POST, etc.) with path
  decorators.push(buildHttpMethodDecorator(method, path));

  // ========================================
  // 5. OpenAPI/Swagger Documentation
  // ========================================
  // Skip documentation if endpoint is excluded
  if (!exclude) {
    // Auto-generate documentation if not fully provided
    // Convert method to string for documentation generation
    const methodStr = typeof method === 'string' ? method : String(method);
    const pathStr: string =
      typeof path === 'string'
        ? path
        : Array.isArray(path) && path.length > 0
          ? (path[0] ?? '')
          : '';

    const docs = autoGenerateDocs(
      methodStr,
      pathStr,
      documentation ?? undefined,
    );

    // Apply tags (auto-generated or custom)
    if (options.documentation?.tags && options.documentation.tags.length > 0) {
      decorators.push(buildApiTags(options.documentation.tags));
    }

    // Add operation documentation
    decorators.push(buildApiOperation(docs));

    // Add content type documentation
    if (consumes && consumes.length > 0) {
      decorators.push(buildApiConsumes(consumes));
    }

    if (produces && produces.length > 0) {
      decorators.push(buildApiProduces(produces));
    }

    // Add parameter documentation
    if (params && params.length > 0) {
      decorators.push(...buildApiParams(params));
    }

    if (queries && queries.length > 0) {
      decorators.push(...buildApiQueries(queries));
    }

    // Add request body documentation
    if (body) {
      decorators.push(buildApiBody(body));
    }

    // Add header documentation
    if (headers && headers.length > 0) {
      decorators.push(...buildApiHeaders(headers));
    }

    // Add response documentation
    if (responses) {
      decorators.push(...buildResponseDecorators(responses));
    }

    // Add authentication documentation
    if (auth) {
      decorators.push(...buildAuthDecorators(auth));
    }
  } else {
    // Exclude from OpenAPI documentation
    decorators.push(ApiExcludeEndpoint());
  }

  // ========================================
  // 6. NestJS Core Decorators
  // ========================================

  // Server-Sent Events
  if (sse) {
    decorators.push(Sse());
  }

  // API Versioning
  if (version) {
    decorators.push(Version(version));
  }

  // HTTP Redirects
  if (redirect) {
    decorators.push(Redirect(redirect.url, redirect.statusCode));
  }

  // Server-side rendering
  if (render) {
    decorators.push(Render(render));
  }

  // Set custom HTTP status code if provided
  if (httpCode !== undefined) {
    decorators.push(HttpCode(httpCode));
  }

  // Set response headers
  if (responseHeaders) {
    Object.entries(responseHeaders).forEach(([key, value]) => {
      decorators.push(Header(key, value));
    });
  }

  // Deprecation support
  if (finalOptions.deprecated) {
    // Note: @nestjs/swagger doesn't have ApiDeprecated decorator yet
    // Use custom metadata and Sunset header for now

    // Add Sunset header if specified
    if (finalOptions.deprecated.sunset) {
      decorators.push(
        Header('Sunset', finalOptions.deprecated.sunset.toUTCString()),
      );
    }

    // Add deprecation notice to response header
    decorators.push(
      Header(
        'X-API-Deprecated',
        finalOptions.deprecated.reason || 'This endpoint is deprecated',
      ),
    );

    // Store deprecation metadata for custom documentation
    decorators.push(SetMetadata('deprecated', finalOptions.deprecated));
  }

  // ========================================
  // 7. Cache Interceptor
  // ========================================
  // Apply cache interceptor when caching is enabled
  if (finalOptions.cache?.enabled) {
    decorators.push(UseInterceptors(CacheInterceptor));

    // Set cache TTL if specified
    if (finalOptions.cache.ttl) {
      decorators.push(CacheTTL(finalOptions.cache.ttl));
    }

    // Set cache key pattern if specified
    if (finalOptions.cache.key) {
      decorators.push(CacheKey(finalOptions.cache.key));
    }

    // Store full cache config as metadata for custom interceptors
    decorators.push(SetMetadata('cache', finalOptions.cache));
  }

  // ========================================
  // 7.5. Throttle/Rate Limiting
  // ========================================
  // Apply throttle decorator when throttling is configured
  if (finalOptions.throttle?.limit && finalOptions.throttle?.ttl) {
    decorators.push(
      Throttle({
        default: {
          limit: finalOptions.throttle.limit,
          ttl: finalOptions.throttle.ttl * 1000, // Convert seconds to milliseconds
        },
      }) as MethodDecorator,
    );
  }

  // ========================================
  // 8. Guards (Authentication/Authorization)
  // ========================================
  if (guards && guards.length > 0) {
    decorators.push(UseGuards(...guards));
  }

  // ========================================
  // 9. Interceptors
  // ========================================
  if (interceptors && interceptors.length > 0) {
    decorators.push(UseInterceptors(...interceptors));
  }

  // ========================================
  // 10. Pipes (Validation/Transformation)
  // ========================================
  if (pipes && pipes.length > 0) {
    decorators.push(UsePipes(...pipes));
  }

  // ========================================
  // 11. Exception Filters
  // ========================================
  if (filters && filters.length > 0) {
    decorators.push(UseFilters(...filters));
  }

  // ========================================
  // 12. Custom Metadata
  // ========================================
  // Store custom metadata for use in guards, interceptors, etc.
  if (metadata) {
    Object.entries(metadata).forEach(([key, value]) => {
      decorators.push(SetMetadata(key, value));
    });
  }

  // Store roles metadata for role-based access control
  if (roles && roles.length > 0) {
    decorators.push(SetMetadata('roles', roles));
  }

  // ========================================
  // 13. Feature-Specific Metadata (for interceptors/guards to read)
  // ========================================

  // Store throttle configuration metadata (granular values)
  if (finalOptions.throttle) {
    if (
      finalOptions.throttle.limit !== undefined ||
      finalOptions.throttle.ttl !== undefined
    ) {
      decorators.push(
        SetMetadata('throttle', {
          limit: finalOptions.throttle.limit,
          ttl: finalOptions.throttle.ttl,
        }),
      );
    }
  }

  // Store CORS configuration metadata
  if (finalOptions.cors) {
    decorators.push(SetMetadata('cors', finalOptions.cors));
  }

  // Store security configuration metadata (granular values)
  if (finalOptions.security) {
    if (finalOptions.security.csp) {
      decorators.push(SetMetadata('csp', finalOptions.security.csp));
    }
    if (finalOptions.security.rateLimit) {
      decorators.push(
        SetMetadata('rateLimit', finalOptions.security.rateLimit),
      );
    }
    if (finalOptions.security.ipWhitelist) {
      decorators.push(
        SetMetadata('ipWhitelist', finalOptions.security.ipWhitelist),
      );
    }
    if (finalOptions.security.requireHttps) {
      decorators.push(SetMetadata('requireHttps', true));
    }
  }

  // Store telemetry configuration metadata
  if (finalOptions.telemetry) {
    decorators.push(SetMetadata('telemetry', finalOptions.telemetry));
  }

  // Store circuit breaker configuration metadata
  if (finalOptions.circuitBreaker) {
    decorators.push(SetMetadata('circuitBreaker', finalOptions.circuitBreaker));
  }

  // Store retry policy configuration metadata
  if (finalOptions.retry) {
    decorators.push(SetMetadata('retry', finalOptions.retry));
  }

  // Store file upload configuration metadata (separate for file vs files)
  if (finalOptions.file) {
    decorators.push(SetMetadata('file', finalOptions.file));
  }

  if (finalOptions.files) {
    decorators.push(SetMetadata('files', finalOptions.files));
  }

  // Store feature flag metadata
  if (finalOptions.featureFlag) {
    decorators.push(SetMetadata('featureFlag', finalOptions.featureFlag));
  }

  // Store logging configuration metadata
  if (finalOptions.logging?.enabled) {
    decorators.push(SetMetadata('logging', finalOptions.logging));
  }

  // Store batch operation configuration metadata
  if (finalOptions.batch?.enabled) {
    decorators.push(SetMetadata('batch', finalOptions.batch));
  }

  // ========================================
  // 14. Apply All Decorators
  // ========================================
  // Compose all decorators into a single decorator
  // applyDecorators applies them in the order they were added
  const finalDecorator = applyDecorators(...decorators) as MethodDecorator;

  // Cache the result for potential reuse
  // Only cache if options object hasn't been modified (still same reference)
  decoratorCache.set(options, finalDecorator);

  return finalDecorator;
}

/**
 * Alias for Route decorator (legacy name).
 *
 * @deprecated Use @Route instead for clarity and brevity
 * @alias Route
 */
export const ApiEndpoint = Route;
