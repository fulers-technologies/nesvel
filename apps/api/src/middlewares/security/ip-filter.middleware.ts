import { Injectable, NestMiddleware, HttpException, HttpStatus } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

/**
 * IP Filter Middleware
 *
 * Controls access based on IP addresses using whitelist and blacklist.
 * Useful for restricting admin panels, internal APIs, or blocking malicious IPs.
 *
 * @description
 * This middleware provides:
 * - IP whitelist (only allow specific IPs)
 * - IP blacklist (block specific IPs)
 * - Support for IP ranges (CIDR notation)
 * - Support for IPv4 and IPv6
 * - Proxy-aware (reads X-Forwarded-For header)
 *
 * @features
 * - Environment-based configuration
 * - CIDR range support (e.g., 192.168.1.0/24)
 * - Blacklist takes precedence over whitelist
 * - Proxy support for load balancers
 * - Detailed rejection logging
 *
 * @author Generated by @nesvel/nestjs-orm
 * @since 1.0.0
 *
 * @example
 * ```typescript
 * // In app.module.ts
 * export class AppModule implements NestModule {
 *   configure(consumer: MiddlewareConsumer) {
 *     consumer
 *       .apply(IpFilterMiddleware)
 *       .forRoutes('/admin/*');  // Protect admin routes
 *   }
 * }
 * ```
 *
 * @example Environment configuration
 * ```env
 * # Whitelist specific IPs (comma-separated)
 * IP_WHITELIST=127.0.0.1,192.168.1.0/24,10.0.0.1
 *
 * # Blacklist malicious IPs
 * IP_BLACKLIST=203.0.113.0,198.51.100.0/24
 * ```
 *
 * @see https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing
 */
@Injectable()
export class IpFilterMiddleware implements NestMiddleware {
  /**
   * Whitelisted IP addresses
   * Empty array means no whitelist (allow all except blacklist)
   *
   * @private
   */
  private readonly whitelist: string[];

  /**
   * Blacklisted IP addresses
   * These IPs are always blocked, even if whitelisted
   *
   * @private
   */
  private readonly blacklist: string[];

  constructor() {
    // Parse whitelist from environment
    const whitelistEnv = process.env.IP_WHITELIST || '';
    this.whitelist = whitelistEnv ? whitelistEnv.split(',').map((ip) => ip.trim()) : [];

    // Parse blacklist from environment
    const blacklistEnv = process.env.IP_BLACKLIST || '';
    this.blacklist = blacklistEnv ? blacklistEnv.split(',').map((ip) => ip.trim()) : [];
  }

  /**
   * Filter requests based on IP address
   *
   * @param req - Express request object
   * @param res - Express response object
   * @param next - Next function to call
   * @throws {HttpException} 403 Forbidden if IP is blocked
   */
  use(req: Request, res: Response, next: NextFunction): void {
    // Get client IP address
    // Check X-Forwarded-For header first (for proxies/load balancers)
    const clientIp = this.getClientIp(req);

    // Check blacklist first (takes precedence)
    if (this.isBlacklisted(clientIp)) {
      throw new HttpException(
        {
          statusCode: HttpStatus.FORBIDDEN,
          message: 'Access denied: IP address is blacklisted',
          error: 'Forbidden',
        },
        HttpStatus.FORBIDDEN
      );
    }

    // If whitelist is configured, check if IP is whitelisted
    if (this.whitelist.length > 0 && !this.isWhitelisted(clientIp)) {
      throw new HttpException(
        {
          statusCode: HttpStatus.FORBIDDEN,
          message: 'Access denied: IP address not whitelisted',
          error: 'Forbidden',
        },
        HttpStatus.FORBIDDEN
      );
    }

    next();
  }

  /**
   * Get client IP address from request
   * Handles proxies and load balancers
   *
   * @param req - Express request object
   * @returns Client IP address
   * @private
   */
  private getClientIp(req: Request): string {
    // Check X-Forwarded-For header (set by proxies)
    const forwardedFor = req.headers['x-forwarded-for'];

    if (forwardedFor) {
      // X-Forwarded-For can contain multiple IPs (client, proxy1, proxy2)
      // The first IP is the original client
      const ips: string = Array.isArray(forwardedFor) ? (forwardedFor[0] ?? '') : forwardedFor;
      return ips.split(',')[0].trim();
    }

    // Fall back to direct connection IP
    return req.ip || req.socket.remoteAddress || 'unknown';
  }

  /**
   * Check if IP is blacklisted
   *
   * @param ip - IP address to check
   * @returns True if IP is blacklisted
   * @private
   */
  private isBlacklisted(ip: string): boolean {
    return this.blacklist.some((blockedIp) => this.matchesIp(ip, blockedIp));
  }

  /**
   * Check if IP is whitelisted
   *
   * @param ip - IP address to check
   * @returns True if IP is whitelisted
   * @private
   */
  private isWhitelisted(ip: string): boolean {
    return this.whitelist.some((allowedIp) => this.matchesIp(ip, allowedIp));
  }

  /**
   * Check if IP matches pattern (supports CIDR notation)
   *
   * @param ip - IP address to check
   * @param pattern - IP pattern (can include CIDR notation like 192.168.1.0/24)
   * @returns True if IP matches pattern
   * @private
   */
  private matchesIp(ip: string, pattern: string): boolean {
    // Exact match
    if (ip === pattern) {
      return true;
    }

    // Check if pattern includes CIDR notation
    if (pattern.includes('/')) {
      return this.matchesCidr(ip, pattern);
    }

    return false;
  }

  /**
   * Check if IP matches CIDR range
   *
   * @param ip - IP address to check
   * @param cidr - CIDR notation (e.g., 192.168.1.0/24)
   * @returns True if IP is in CIDR range
   * @private
   */
  private matchesCidr(ip: string, cidr: string): boolean {
    // Basic CIDR matching for IPv4
    // For production, consider using a library like 'ip-range-check'

    const [range, bits] = cidr.split('/');
    const mask = ~((1 << (32 - parseInt(bits || '32'))) - 1);

    const ipNum = this.ipToNumber(ip);
    const rangeNum = this.ipToNumber(range || '0.0.0.0');

    return (ipNum & mask) === (rangeNum & mask);
  }

  /**
   * Convert IPv4 address to number
   *
   * @param ip - IPv4 address
   * @returns Numeric representation
   * @private
   */
  private ipToNumber(ip: string): number {
    const parts = ip.split('.');
    return (
      (parseInt(parts[0] || '0') << 24) +
      (parseInt(parts[1] || '0') << 16) +
      (parseInt(parts[2] || '0') << 8) +
      parseInt(parts[3] || '0')
    );
  }
}
