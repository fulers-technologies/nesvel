import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

/**
 * Auth Context Middleware
 *
 * Extracts and validates authentication tokens (JWT, Bearer, API Key) and
 * sets user context in the request object for use throughout the application.
 *
 * @description
 * This middleware:
 * - Extracts authentication tokens from headers
 * - Validates JWT tokens (basic validation)
 * - Decodes user information from tokens
 * - Sets user context in request object
 * - Supports multiple auth methods (Bearer, API Key, Cookie)
 *
 * @features
 * - JWT token extraction and decoding
 * - Bearer token support
 * - API key authentication
 * - Cookie-based authentication
 * - User context propagation
 * - Non-blocking (continues even without auth)
 *
 * @author Generated by @nesvel/nestjs-orm
 * @since 1.0.0
 *
 * @example
 * ```typescript
 * // In app.module.ts
 * export class AppModule implements NestModule {
 *   configure(consumer: MiddlewareConsumer) {
 *     consumer
 *       .apply(AuthContextMiddleware)
 *       .forRoutes('*');
 *   }
 * }
 * ```
 *
 * @example Accessing user context in controllers
 * ```typescript
 * @Get()
 * async findAll(@Req() req: Request) {
 *   const user = req['user'];
 *   console.log(user);
 *   // { id: '123', email: 'user@example.com', roles: ['admin'] }
 * }
 * ```
 *
 * @example Client request
 * ```http
 * GET /api/users
 * Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
 * ```
 */
@Injectable()
export class AuthContextMiddleware implements NestMiddleware {
  /**
   * Extract auth context and set user in request
   *
   * @param req - Express request object
   * @param res - Express response object
   * @param next - Next function to call
   */
  use(req: Request, res: Response, next: NextFunction): void {
    try {
      // Extract token from various sources
      const token = this.extractToken(req);

      if (token) {
        // Decode token (basic JWT decode without verification for context)
        // In production, use a proper JWT library with signature verification
        const decoded = this.decodeToken(token);

        if (decoded) {
          // Set user context in request object
          req['user'] = decoded;

          // Add user ID to response headers (optional, for debugging)
          if (decoded.id && process.env.NODE_ENV === 'development') {
            res.setHeader('X-User-ID', decoded.id);
          }
        }
      }
    } catch (error) {
      // Log error but don't block request
      // Authentication guards will handle actual auth failures
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      console.error('Auth context error:', errorMessage);
    }

    next();
  }

  /**
   * Extract authentication token from request
   *
   * @param req - Express request object
   * @returns Token string or null
   * @private
   */
  private extractToken(req: Request): string | null {
    // Check Authorization header (Bearer token)
    const authHeader = req.headers.authorization;
    if (authHeader && authHeader.startsWith('Bearer ')) {
      return authHeader.substring(7);
    }

    // Check for API key in header
    const apiKey = req.headers['x-api-key'] as string;
    if (apiKey) {
      return apiKey;
    }

    // Check for token in cookies
    const cookieToken = req.cookies?.token || req.cookies?.auth_token;
    if (cookieToken) {
      return cookieToken;
    }

    // Check query parameter (not recommended for production)
    const queryToken = req.query.token as string;
    if (queryToken && process.env.NODE_ENV !== 'production') {
      return queryToken;
    }

    return null;
  }

  /**
   * Decode JWT token (basic decode without verification)
   * Note: In production, use proper JWT verification with secret/public key
   *
   * @param token - JWT token string
   * @returns Decoded payload or null
   * @private
   */
  private decodeToken(token: string): any | null {
    try {
      // Basic JWT decode (splits token and base64 decodes payload)
      // Format: header.payload.signature
      const parts = token.split('.');

      if (parts.length !== 3) {
        return null;
      }

      // Decode payload (second part)
      const payload = parts[1];
      if (!payload) {
        return null;
      }
      const decoded = Buffer.from(payload, 'base64').toString('utf-8');

      return JSON.parse(decoded);
    } catch (error) {
      return null;
    }
  }
}
